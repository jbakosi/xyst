/*!
  \page      inciter_example_hump Inciter: Integrating the scalar advection equation for a smooth problem

This example runs @ref inciter_main to integrate the advection equation (see,
e.g., PDE/Transport/CGTransport.h) configured to solve only the smooth portion of
Zalesak's slotted cylinder (inciter::TransportProblemSlotCyl) problem.

This example slightly differs from @ref inciter_example_slot_cyl, in that the
non-smooth regions are commented out. This can be used to estimate the order of
converge of the spatial and teporal discretization for smooth problems.

The following modification, applied in PDE/Transport/Problem/SlotCyl.h, removes
the non-smooth part of the solution from the slotted cylinder case:
@code{.C}
class TransportProblemSlotCyl {

  private:
    using ncomp_t = tk::ctr::ncomp_type;

  public:
    //! Evaluate analytical solution at (x,y,t) for all components
    //! \param[in] ncomp Number of components in this transport equation system
    //! \param[in] x X coordinate where to evaluate the solution
    //! \param[in] y Y coordinate where to evaluate the solution
    //! \param[in] t Time where to evaluate the solution
    //! \return Values of all components evaluated at (x,y,t)
    static std::vector< tk::real >
    solution( ncomp_t, ncomp_t ncomp,
              tk::real x, tk::real y, tk::real, tk::real t )
    {
      using std::sin; using std::cos;
      std::vector< tk::real > s( ncomp, 0.0 );
      for (ncomp_t c=0; c<ncomp; ++c) {
        auto T = t + 2.0*M_PI/ncomp * c;
        const tk::real R0 = 0.15;
        // center of the cone
        tk::real x0 = 0.5;
        tk::real y0 = 0.25;
        tk::real r = std::sqrt((x0-0.5)*(x0-0.5) + (y0-0.5)*(y0-0.5));
        tk::real kx = 0.5 + r*sin( T );
        tk::real ky = 0.5 - r*cos( T );
        // center of the hump
        x0 = 0.25;
        y0 = 0.5;
        r = std::sqrt((x0-0.5)*(x0-0.5) + (y0-0.5)*(y0-0.5));
        tk::real hx = 0.5 + r*sin( T-M_PI/2.0 ),
                 hy = 0.5 - r*cos( T-M_PI/2.0 );
        // center of the slotted cylinder
        x0 = 0.5;
        y0 = 0.75;
        r = std::sqrt((x0-0.5)*(x0-0.5) + (y0-0.5)*(y0-0.5));
        tk::real cx = 0.5 + r*sin( T+M_PI ),
                 cy = 0.5 - r*cos( T+M_PI );
        // end points of the cylinder slot
        tk::real i1x = 0.525, i1y = cy - r*cos( std::asin(0.025/r) ),
                 i2x = 0.525, i2y = 0.8,
                 i3x = 0.475, i3y = 0.8;
        // rotate end points of cylinder slot
        tk::real ri1x = 0.5 + cos(T)*(i1x-0.5) - sin(T)*(i1y-0.5),
                 ri1y = 0.5 + sin(T)*(i1x-0.5) + cos(T)*(i1y-0.5),
                 ri2x = 0.5 + cos(T)*(i2x-0.5) - sin(T)*(i2y-0.5),
                 ri2y = 0.5 + sin(T)*(i2x-0.5) + cos(T)*(i2y-0.5),
                 ri3x = 0.5 + cos(T)*(i3x-0.5) - sin(T)*(i3y-0.5),
                 ri3y = 0.5 + sin(T)*(i3x-0.5) + cos(T)*(i3y-0.5);
        // direction of slot sides
        tk::real v1x = ri2x-ri1x, v1y = ri2y-ri1y,
                 v2x = ri3x-ri2x, v2y = ri3y-ri2y;
        // lengths of direction of slot sides vectors
        tk::real v1 = std::sqrt(v1x*v1x + v1y*v1y),
                 v2 = std::sqrt(v2x*v2x + v2y*v2y);
        // cone
//         r = std::sqrt((x-kx)*(x-kx) + (y-ky)*(y-ky)) / R0;
//         if (r<1.0) s[c] = 0.6*(1.0-r);
        // hump
        r = std::sqrt((x-hx)*(x-hx) + (y-hy)*(y-hy)) / R0;
        if (r<1.0) s[c] = 0.2*(1.0+cos(M_PI*std::min(r,1.0)));
        // cylinder
//         r = std::sqrt((x-cx)*(x-cx) + (y-cy)*(y-cy)) / R0;
//         const std::array< tk::real, 2 > r1{{ v1x, v1y }},
//                                         r2{{ x-ri1x, y-ri1y }};
//         const auto d1 = (r1[0]*r2[1] - r2[0]*r1[1]) / v1;
//         const std::array< tk::real, 2 > r3{{ v2x, v2y }},
//                                         r4{{ x-ri2x, y-ri2y }};
//         const auto d2 = (r3[0]*r4[1] - r4[0]*r3[1]) / v2;
//         if (r<1.0 && (d1>0.05 || d1<0.0 || d2<0.0)) s[c] = 0.6;
      }
      return s;
    }
  ...
}
@endcode

@section inciter_example_hump_control Control file

The control file is the same as that of the slotted cylinder problem, see also
inciter_exampl_slot_cyl.

@code{.bash}
# vim: filetype=sh:
# This is a comment
# Keywords are case-sensitive

title "Zalesak's slotted cylinder"

inciter

  #nstep 10  # Max number of time steps
  #term 6.28318530718  # Max time = 2*pi
  term 1.57079632679  # Max time = pi/2
  #term 0.78539816339  # Max time = pi/4
  #term 0.39270  # Max time = pi/8
  cfl  0.5
  ttyi 10      # TTY output interval
  ctau 1.0  # FCT mass diffusivity

  transport
    physics advection
    problem slot_cyl
    ncomp 1
  end

  field_output
    interval 100
  end

end
@endcode


@section inciter_example_hump_run Example run on 36 CPUs
\verbatim
$ ./charmrun +p36 Main/inciter -v -c slot_cyl.q -i unitcube_01_750K.exo
\endverbatim

@section inciter_example_hump_fieldvis Example visualization

Example visualization of the 3D field data result with
[ParaView](https://www.paraview.org).

@code{.bash}
paraview out.0
@endcode

@section inciter_example_hump_error L2 errors

The following figure shows the time evolution of the
\f$\color[HTML]{dcdcdc}L_2\f$ error for three different meshes whose edge
lengths are successively halved, which indicates approximately second-order
convergence. See also
https://github.com/quinoacomputing/quinoa-examples/tree/master/inciter/Hump for
the diagnostics files.

@m_div{m-col-m-10 m-center-m}
<img src="images/l2.svg"/>
@m_enddiv

Gnuplot commands to reproduce the above plot:

@code{.bash}
plot "diag.750K" u 2:4, "diag.6M" u 2:4, "diag.48M" u 2:4
@endcode

*/
